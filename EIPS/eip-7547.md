---
eip: 7547
title: Inclusion lists
description: Add an inclusion list mechanism to allow forced transaction inclusion.
author: mike (@michaelneuder), Vitalik (@vbuterin), Francesco (@fradamt), Terence (@terencechain), potuz (@potuz), Manav (@manav2401)
discussions-to: https://ethereum-magicians.org/t/eip-7547-inclusion-lists/17474
status: Draft
type: Standards Track
category: Core
created: 2023-10-24
---
## Abstract

Censorship resistance is a core value proposition of blockchains. Inclusion lists aim to provide a mechanism to improve the censorship resistance of Ethereum by allowing proposers to specify a set of transactions that must be promptly included for subsequent blocks to be considered valid. 

## Motivation

Since the merge, validators have started outsourcing almost all block production to a specialized set of builders who compete to extract the most MEV (this is commonly referred to as Proposer-Builder Separation). As of October 2023, nearly 95% of blocks are built by builders rather than the proposer. While it is great that all proposers have access to competitive blocks through the `mev-boost` ecosystem, a major downside of externally built blocks is the fact that the builders ultimately decide what transactions to include or exclude. Without any forced transaction inclusion mechanism, the proposer is faced with a difficult choice: they either have no say on the transactions that get included, or they build the block locally (thus have the final say on transactions) and sacrifice some MEV rewards. 

Inclusion lists aim to allow proposers to retain some authority by providing a mechanism by which transactions can be forcibly included. The simplest design is for the `slot N` proposer to specify a list of transactions that must be included in the block that is produced for their slot. However, this is not incentive-compatible because builders may choose to abstain from building blocks if the proposer sets some constraints on their behavior. This leads to the idea of "forward" inclusion lists, where the transactions specified by the `slot N` proposer are enforced in the `slot N+1` block. The naïve implementation of the forward inclusion lists presents a different issue of potentially exposing free data availability, which could be exploited to bloat the size of the chain without paying the requisite gas costs. The free data availability problem is solved with observations about nonce reuse and allowing multiple inclusion lists to be specified for each slot. With the incentive compatibility and free data availability problems addressed, we can more safely proceed with the implementation of inclusion lists.

## High-level overview

**`slot N` proposal:**

- Proposer broadcasts a signed block and an inclusion list (summary and transactions objects) for `slot N+1`.
- Transactions will be included in `slot N` or `slot N+1`.
- Summaries include the originating address of the transactions and their respective gas limits.
- Summaries are signed, but transactions are not.

**`slot N` validation:**

- Validators only consider the block for validation and fork-choice if they have seen at least one inclusion list for that slot.
- They consider the block invalid if the inclusion list transactions are not executable at the start of `slot N` or if the transactions' `max_fee_per_gas` are not at least 12.5% higher than the current slot (to ensure the transactions will be valid in `slot N+1`).

**`slot N+1` validation:**

- The proposer for `slot N+1` builds their block along with a signed summary from the `slot N` proposer.
- The payload includes a list of transaction indices from the `slot N` payload that satisfy some entry in the signed inclusion list summary.
- The payload is considered valid if: (a) the execution conditions are met, including satisfying the inclusion list summary and being executable from the execution layer perspective, and (b) the consensus conditions are met with a proposer signature of the previous block.


## Specification

### Configuration

| Name | Value |
| - | - |
| `MAX_TRANSACTIONS_PER_INCLUSION_LIST` | `2**4 = 16` |
| `MAX_GAS_PER_INCLUSION_LIST` | `2**21` |
| `MIN_SLOTS_FOR_INCLUSION_LIST_REQUEST` | `1` |

### Consensus layer

#### Reference Objects

```
class InclusionListSummary(Container)
    slot: Slot
    proposer_index: ValidatorIndex
    summary: List[ExecutionAddress, MAX_TRANSACTIONS_PER_INCLUSION_LIST]
```

```
class SignedInclusionListSummary(Container):
    message: InclusionListSummary
    signature: BLSSignature
```

```
class InclusionList(Container)
    summary: SignedInclusionListSummary
    parent_hash: Hash32
    transactions: List[Transaction, MAX_TRANSACTIONS_PER_INCLUSION_LIST]
```

```
class SignedInclusionList(Container)
    message: InclusionList
    signature: BLSSignature
```

```
class BeaconBlockBody(Container):
    ...
    inclusion_list_summary: SignedInclusionListSummary
```

#### Specific Changes

**Beacon chain state transition spec:**

- ***New** `ExecutionAddress` object* 
- ***New** `InclusionListSummary` object*, a reduced version of the full inclusion list
- ***Modified** `BeaconBlockBody`*, with the addition of the inclusion list summary.

**Beacon chain fork-choice spec:**

- ***New** `is_inclusion_list_available` check:* Introduce a new check to determine if the inclusion list is available within the visibility window.
 
**Beacon chain P2P spec:**

- ***New** `inclusion_list` object:* Introduce a new `inclusion_list` for the proposer to submit and nodes to process.
- ***New** gossipnet and validation rules for inclusion list:* Define new rules for handling the inclusion list in the gossip network and validation.
- ***New** RPC request and response network for inclusion list:* Establish a new network for sending and receiving inclusion lists.


**Validator spec:**

- ***New** duty for `inclusion_list`:* Proposer to prepare and sign the inclusion list.
- ***Modified** duty for `BeaconBlockBody`:* Update the duty to prepare the beacon block body to include the `inclusion_list_summary`.


### Execution layer

####  Block structure and validity

Beginning at the execution timestamp `FORK_TIMESTAMP`, execution clients **MUST** extend the header schema with an additional field: the `inclusion_list_summary`.

The resulting RLP encoding of the header is therefore:

```python
rlp([
    parent_hash,
    0x1dcc4de8dec75d7aab85b567b6ccd41ad312451b948a7413f0a142fd40d49347, # ommers hash
    coinbase,
    state_root,
    txs_root,
    receipts_root,
    logs_bloom,
    0, # difficulty
    number,
    gas_limit,
    gas_used,
    timestamp,
    extradata,
    prev_randao,
    0x0000000000000000, # nonce
    base_fee_per_gas,
    withdrawals_root,
    blob_gas_used,
    excess_blob_gas,
    parent_beacon_block_root,
    inclusion_list_summary,
])
```

Validity of the block is extended to require that `inclusion_list_summary` is satisfied, meaning that each address in the list is the address of either a transactions in the current block or one in the parent block. In order to perform this validation, we introduce the `parent_transactions_addresses` contract, a new system contract to store the addresses of the transactions in the latest block.

#### Parent transactions addresses contract

The parent transactions addresses contract reverts whenever called by a `caller` other than `SYSTEM_ADDRESS`. It has two operations: `set` and `get`. The first byte of the input is used to determine which operation is performed, `b'\x00'` for set and `b'\x01'` for get. 

##### `set`

* Caller sets the first byte to `b'\x00'`, the next 32 bytes as the number of addresses that are passed, and the rests of the input is a concatenation of the addresses
* Set the storage value at 0 to be `evm.calldata[1:33]`, the number of addresses that are passed
* For each address, i.e., every following chunk of 20 bytes in evm.calldata, set the first available storage slot to that

##### `get`

* Caller sets the first byte to `b'\x01'`
* The number of addresses `num_addresses` stored by the parent block is retrieved from storage slot 0
* Addresses are retrieved from storage slots 1 to `num_addresses+1`, and returned

##### Pseudocode

```python
if evm.caller != SYSTEM_ADDRESS:
    evm.revert()
elif evm.calldata[0] == b'\x00'
    set()
else:
    get()


def get():
    num_addresses = to_uint256_be(storage.get(0))
    addresses = b''
    for i in range(num_addresses):
        addresses += storage.get(i+1)

    evm.return(addresses)

def set():
    num_addresses = to_uint256_be(evm.calldata[1:33])
    storage.set(0, evm.calldata[1:33])
    for i in range(num_addresses):
        storage.set(i+1, evm.calldata[20*i+33])
```

##### Bytecode

TBD.

##### Deployment

TBD.

### Engine API

- ***New** `new_inclusion_list`:* Implement a new call to notify the Execution Layer (EL) client about a new inclusion list. This includes a `parentHash`, and  the EL checks that each transaction is valid with respect to the state of the corresponding `parent` block, and has a `max_basefee_per_gas` at least 12.5% higher than `parent.basefeePerGas`.  Moreover, it checks that the sum of gas limits of the inclusion list transactions is at most `MAX_GAS_PER_INCLUSION_LIST`.
- ***New** `get_inclusion_list`:* Introduce a new function for proposers to retrieve inclusion lists.


## Rationale

We consider a few design decisions present in this EIP. 

1. `ReducedSummary` versus `Summary`
    - The original proposal tries to improve data efficiency by using a `ReducedSummary` and a `Rebuilder`. This allows the full summary to be reconstructed. 
    - This adds a lot of complexity to the spec, so in this initial version, we should consider just using the regular `Summary` and including that in the subsequent block.
3. Gas limit vs no limit. 
    - One consideration is whether the inclusion list should have a gas limit or use the block’s gas limit.
    - Having a separate gas limit simplifies complexity but opens up the possibility for validators to outsource their inclusion list construction for side payments (e.g., if a block is full, the proposer could auction off space in the inclusion list for guaranteed inclusion in the subsequent block).
    - Alternatively, inclusion lists could be part of the block gas limit and only satisfied if the block gas limit is not full. However, this could lead to situations where the next block proposer intentionally fills up the block to ignore the inclusion list, albeit at the potential expense of paying to waste the gas.
4. Inclusion list ordering.
    - We assume that the inclusion list is processed at the top of the `slot N` block. Transactions in the inclusion list are evaluated for the pre-state of `slot N` but are only guaranteed to be included in `slot N+1`.
3. Inclusion list transaction exclusion.
    - Inclusion list transactions proposed at `slot N` may be satisfied in the same slot (e.g., by being included in the `ExecutionPayload`). This is a side effect of validators using `mev-boost` because they don’t know the contents of the block they propose.
    - Due to this, there exists an exclusion field, a node looks at each transaction in the payload’s `inclusion_list_exclusion` field and makes sure it matches with a transaction in the current inclusion list. When there’s a match, we remove that transaction from the inclusion list summary.
4. `mev-boost` compatibility.
    - There are no significant changes to `mev-boost`. Like any other hard fork, `mev-boost`, relays, and builders must adjust their beacon nodes.
    - Builders must know that execution payloads that don’t satisfy the inclusion list summary will be invalid.
    - Relays may have additional duties to verify such constraints before passing them to validators for signing.
    - When receiving the header, validators can check that the `inclusion_list_summary_root` matches their local version and skip building a block if there’s a mismatch, using the local block instead.
5. Syncing using by range or by root.
    - To consider a block valid, a node syncing to the latest head must also have an inclusion list.
    - A block without an inclusion list cannot be processed during syncing.
    - To address this, there is a parameter called `MIN_SLOTS_FOR_INCLUSION_LIST_REQUEST`. A node can skip inclusion list checks if the block’s slot plus this parameter is lower than the current slot.
    - This is similar to [EIP-4844](./eip-4844.md), where a node skips blob sidecar data availability checks if it’s outside the retention window.

## Backwards Compatibility

This EIP introduces backward incompatible changes to the block validation rule set on the consensus layer and must be accompanied by a hard fork. These changes do not break anything related to current user activity and experience.

## Security Considerations

The main potential issue is around the incentivization of the inclusion lists. If the `slot N` proposer constructs an inclusion list that negatively impacts the rewards of the `slot N+1` proposer, the `slot N+1` proposer may attempt to bribe the `slot N` proposer to publish an empty list. This isn't a direct attack on the protocol, but rather a profit-sharing mechanism by which the inclusion list would go unutilized. It seems likely these commitment games could be played no matter the censorship resistance scheme in place, but this remains an active area of research.


## Copyright

Copyright and related rights waived via [CC0](../LICENSE.md).
